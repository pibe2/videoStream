@model VideoStreamingAspMvc.Models.Video


@using (Html.BeginForm(
    actionName: "UploadVideoAjax",
    controllerName: "Videos",
    method: FormMethod.Post,
    htmlAttributes: new { @class = "form-horizontal", @enctype = "multipart/form-data", @role = "form", @id = "theForm" }
)) {
    <div class="form-group row">
        <div class="col-sm-offset-2">
            <div class="file-control-wide">
                <label class="btn btn-default text-center" for="videoFile">
                    <input id="videoFile" name="videoFile" type="file" style="display:none"
                        onchange="videoFileSelected(this)" />
                    Browse
                </label>
                <input type="text" class="file-control-text" id="fileNameLabel" disabled />
            </div>
        </div>
    </div>

    <div class="form-group">
        @Html.HiddenFor(m => m.Id)

        <div class="col-sm-offset-2">
            <button type="button" class="btn btn-primary" onclick="uploadVideoAjax(); return false;">Upload</button>
            @Html.ActionLink("Save Without Video", "Index", "Videos", new { @class = "btn btn-default" })
        </div>
    </div>
}


<script type="text/javascript">

    function videoFileSelected(fileInput) {
        let file = fileInput.files[0];
        if (file)
            $("#fileNameLabel").val(file.name); // update fileNameLabel
    }


    function uploadVideoAjax() {
        let fileInput = $("#videoFile")[0];
        let file = fileInput.files[0]

        let maxFileSize = 4 * 1024 * 1024 * 1024; // 4GB
        if (!file || file.size == 0 || file.size > maxFileSize) {
            console.log("empty/no file uploaded, or file size too large (larger than 4GB)");
            console.log("try uploading a non empty file not greater than 4GB in size");
            return;
        }

        uploadFile(file);
    }

    function uploadFile(file) {
        let regChunkSize = 50 * 1024 * 1024; // split file into 50mb chunks
        let numRegChunks = Math.trunc(file.size/regChunkSize);
        let numChunks = numRegChunks;

        let lastChunkSize = file.size - (numRegChunks * regChunkSize);

        if (lastChunkSize > 0)
            numChunks = numRegChunks + 1;

        let chunkUploadTasks = [];
        for (let i = 0; i < numRegChunks; i++) {
            let chunkStart = i * regChunkSize;
            let chunkEnd = (i + 1) * regChunkSize;
            let chunkNo = i + 1;
            let chunk = file.slice(chunkStart, chunkEnd);
            chunkUploadTasks.push(
                function () { return uploadChunk(chunk, chunkNo, numChunks); }
            );
        }
        // add last chunk task
        if (lastChunkSize > 0) {    // upload last chunk
            let lastChunk = file.slice(file.size - lastChunkSize, file.size);
            chunkUploadTasks.push(
                function () { return uploadChunk(lastChunk, numChunks, numChunks); }
            );
        }

        // make sure all but the last chunk are uploaded, then upload the last one so server knows when to merge
        let firstChunkUploadTasks = chunkUploadTasks.slice(0, chunkUploadTasks.length - 1);
        let firstTasksAjaxResults = firstChunkUploadTasks.map(function (task) { return task(); })
        let lastChunkUploadTask = chunkUploadTasks[chunkUploadTasks.length - 1];
        $.when.apply($, firstTasksAjaxResults).then(lastChunkUploadTask);
    }

    function uploadChunk(chunk, chunkNo, numChunks) {
        // file.slice doesn't actually exclude tha last byte (at chunk end)
        let chunkName = "@Model.Id" + "_" + chunkNo + "_" + numChunks + "_" + file.name;
       
        let formData = new FormData();
        formData.append('file', chunk, chunkName);

        let postUrl = $("#theForm").attr("action");

        return $.ajax({     // returns the ajax call result so we can wait for it
            type: "POST",
            url: postUrl,
            contentType: false,
            processData: false,
            data: formData,
            success: function (data) {
                    console.log("success in chunk upload", chunkNo, "out of", numChunks);
                    console.log(data);
                },
            error: function (err) {
                    console.log("error in chunk upload", chunkNo, "out of", numChunks);
                    console.log(error);
                }
        });
    }






















    /*
    function uploadVideoAjax() {
        var theForm = $("#theForm");

        // since the form control names and ids match the controller parameter names, 
        // they will be mapped to them!
        var formData = new FormData(theForm[0]);
        var xhr = new XMLHttpRequest();

        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                console.log(xhr.responseText);
            }
        }

        xhr.upload.addEventListener("progress", function (e) {
            // it will never come inside here
            if (e.lengthComputable) {
                console.log("progress:", e.loaded, "out of", e.total, "(", parseInt((e.loaded / e.total) * 100), "%)");
            }
            else {
                console.log("upload progress is not computable");
            }

        });

        xhr.upload.addEventListener("error", function (e) {
            console.log("upload error: ");
            console.log(e);
        });

        xhr.addEventListener("error", function (e) {
            console.log("post error occurred");
        });

        xhr.addEventListener("timeout", function (e) {
            console.log("timed out: ");
            console.log(e);
        });

        xhr.upload.addEventListener("timeout", function (e) {
            console.log("timed out 2: ");
            console.log(e);
        });


        xhr.open(theForm.attr("method"), theForm.attr("action"));
        xhr.send(formData);
    }
    */
</script>
