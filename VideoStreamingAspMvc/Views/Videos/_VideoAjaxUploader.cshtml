@model VideoStreamingAspMvc.Models.Video


@using (Html.BeginForm(
    actionName: "UploadVideoChunkAjax",
    controllerName: "Videos",
    method: FormMethod.Post,
    htmlAttributes: new { @class = "form-horizontal", @enctype = "multipart/form-data", @role = "form", @id = "theForm" }
)) {
    <div class="form-group row">
        <div class="col-sm-offset-2">
            <div class="file-control-wide">
                <label class="btn btn-default text-center" for="videoFile">
                    <input id="videoFile" name="videoFile" type="file" style="display:none"
                        onchange="videoFileSelected(this)" />
                    Browse
                </label>
                <input type="text" class="file-control-text" id="fileNameLabel" disabled />
            </div>
        </div>
    </div>

    <div class="form-group">
        @Html.HiddenFor(m => m.Id)

        <div class="col-sm-offset-2">
            <button type="button" class="btn btn-primary" onclick="uploadVideo(); return false;">Upload</button>
            @Html.ActionLink("Save Without Video", "Index", "Videos", new { @class = "btn btn-default" })
        </div>
    </div>
}


<script type="text/javascript">

    function videoFileSelected(fileInput) {
        let file = fileInput.files[0];
        if (file)
            $("#fileNameLabel").val(file.name); // update fileNameLabel
    }


    function uploadVideo() {
        let fileInput = $("#videoFile")[0];
        let file = fileInput.files[0]

        let maxFileSize = 4 * 1024 * 1024 * 1024; // 4GB
        if (!file || file.size == 0 || file.size > maxFileSize) {
            console.log("empty/no file uploaded, or file size too large (larger than 4GB)");
            console.log("try uploading a non empty file not greater than 4GB in size");
            return;
        }

        //uploadVideoAjax(file);
        uploadVideoXhr(file);
    }

    function uploadVideoAjax(file) {
        let regChunkSize = 50 * 1024 * 1024; // split file into 50mb chunks
        let numRegChunks = Math.trunc(file.size/regChunkSize);
        let numChunks = numRegChunks;

        let lastChunkSize = file.size - (numRegChunks * regChunkSize);

        if (lastChunkSize > 0)
            numChunks = numRegChunks + 1;

        let chunkUploadTasks = [];
        for (let i = 0; i < numRegChunks; i++) {
            chunkUploadTasks.push(
                function () { return uploadChunkAjax(file, i * regChunkSize, (i + 1) * regChunkSize, i + 1, numChunks); }
            );
        }
        // add last chunk task
        if (lastChunkSize > 0) {    // upload last chunk
            chunkUploadTasks.push(
                function () { return uploadChunkAjax(file, file.size - lastChunkSize, file.size, numChunks, numChunks); }
            );
        }

        // make sure all but the last chunk are uploaded, then upload the last one so server knows when to merge
        let firstChunkUploadTasks = chunkUploadTasks.slice(0, chunkUploadTasks.length - 1);
        let firstTasksAjaxResults = firstChunkUploadTasks.map(function (task) { return task(); })
        let lastChunkUploadTask = chunkUploadTasks[chunkUploadTasks.length - 1];
        $.when.apply($, firstTasksAjaxResults).then(lastChunkUploadTask);
    }

    function uploadChunkAjax(file, chunkStart, chunkEnd, chunkNo, numChunks) {
        // file.slice doesn't actually exclude tha last byte (at chunk end)
        let chunk = file.slice(chunkStart, chunkEnd);

        let chunkName = "@Model.Id" + "-" + numChunks + "-" + chunkNo + "-" + file.name;
       
        let formData = new FormData();
        formData.append('file', chunk, chunkName);

        let postUrl = $("#theForm").attr("action");

        return $.ajax({     // returns the ajax call result so we can wait for it
            type: "POST",
            url: postUrl,
            contentType: false,
            processData: false,
            data: formData,
            success: function (data) {
                    console.log("success in chunk upload", chunkNo, "out of", numChunks);
                    console.log(data);
                },
            error: function (err) {
                    console.log("error in chunk upload", chunkNo, "out of", numChunks);
                    console.log(error);
                }
        });
    }


    function uploadVideoXhr(file) {
        let regChunkSize = 50 * 1024 * 1024; // split file into 50mb chunks
        let numRegChunks = Math.trunc(file.size / regChunkSize);
        let numChunks = numRegChunks;

        let lastChunkSize = file.size - (numRegChunks * regChunkSize);

        if (lastChunkSize > 0)
            numChunks = numRegChunks + 1;

        let chunksInfo = [];

        // create tasks 
        // can't push in naked promises since promises start executing as soon as they're created
        // <see:https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html advanced mistake #3>

        for (let i = 0; i < numRegChunks; i++) {
            chunksInfo.push({
                    chunkStart: i * regChunkSize,
                    chunkStop: (i + 1) * regChunkSize,
                    chunkNo: i + 1
            });
        }
        // add potential last chunk task
        if (lastChunkSize > 0) {    // upload last chunk
            chunksInfo.push({
                    chunkStart: file.size - lastChunkSize,
                    chunkStop: file.size,
                    chunkNo: numChunks
            });
        }

        // make sure all but the last chunk are uploaded, then upload the last one so server knows when to merge
        let firstChunksInfo = chunksInfo.slice(0, chunksInfo.length - 1);
        let lastChunkInfo = chunksInfo[chunksInfo.length - 1];

        let firstPromises = firstChunksInfo.map((info) =>
            // promises start executing on creation
            new Promise((resolve, reject) =>
                uploadChunkXhr(file, info.chunkStart, info.chunkStop, info.chunkNo, numChunks, resolve, reject)
            )
        );

        Promise.all(firstPromises)
            .then((resolveResults) => {
                console.log("done with the first chunks, starting the last");
                console.log(resolveResults);
                // promises start executing on creation, and want to have proper resolve and reject funcs
                return new Promise((resolve, reject) =>
                    uploadChunkXhr(file, lastChunkInfo.chunkStart, lastChunkInfo.chunkStop, lastChunkInfo.chunkNo, numChunks, resolve, reject)
                );
            })
            .catch(console.log.bind(console));
    }

    function uploadChunkXhr(file, chunkStart, chunkEnd, chunkNo, numChunks, resolve, reject) {
        // file.slice doesn't actually exclude tha last byte (at chunk end)
        let chunk = file.slice(chunkStart, chunkEnd);

        let chunkName = "@Model.Id" + "-" + numChunks + "-" + chunkNo + "-" + file.name;

        let formData = new FormData();
        formData.append('file', chunk, chunkName);

        let postUrl = $("#theForm").attr("action");

        let xhr = new XMLHttpRequest();

        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                console.log(xhr.responseText);
                resolve("chunk posted successfully done")
            }
        }

        xhr.upload.addEventListener("progress", function (e) {
            // it will never come inside here
            if (e.lengthComputable) {
                console.log("progress:", parseInt((e.loaded / e.total) * 100)+"%", "for chunk", chunkNo, "out of", numChunks);
            }
            else {
                console.log("upload progress is not computable");
            }

        });

        xhr.upload.addEventListener("error", function (e) {
            console.log("upload error: ");
            console.log(e);
            reject("upload error: " + e);
        });

        xhr.addEventListener("error", function (e) {
            console.log("post error occurred");
            reject("upload error: " + e);
        });

        xhr.addEventListener("timeout", function (e) {
            console.log("timed out: ");
            console.log(e);
            reject("upload error: " + e);
        });

        xhr.upload.addEventListener("timeout", function (e) {
            console.log("timed out 2: ");
            console.log(e);
            reject("upload error: " + e);
        });


        xhr.open("POST", postUrl, true); // true = run it synchronously
        xhr.send(formData);
    }

</script>
